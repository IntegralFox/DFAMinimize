#!/bin/python
'''
DFA Minimizer
'''
import sys
from util import *

# File name of DFA spec is the last element of the arg list
filename = sys.argv[-1]
if filename == "-" or filename == "minimize":
	file = stdin
else:
	file = open(filename)

# Read in the dfa and extract the states and keys from it
dfa = DFA(file)

# Create a distinction dictionary/map and initialize it with the finality
# comparison between states
distinct = {}
for i in range(0, len(dfa.key) - 1):
	key = dfa.key[i]
	distinct[key] = {}
	# Only compare with the keys that follow the current key
	compareWith = dfa.key[i + 1:]
	for compareKey in compareWith:
		# Set the distinct flag if one state is final and the other not
		distinct[key][compareKey] = xor(dfa.state[key].final, dfa.state[compareKey].final)

print(distinct)

# Repeatedly loop over the distinction array updating the distinctions until
# it no longer gets changed
modified = True
while modified:
	modified = False
	for key in distinct:
		print("key: " + key)
		for compareKey in distinct[key]:
			print("compare: " + compareKey)
			if not distinct[key][compareKey]:
				print("checking distinction")
				for symbol in dfa.alphabet:
					# The jagged distinction matrix uses keys in alphabetical order
					trans0 = min(
						dfa.state[key].transition[symbol],
						dfa.state[compareKey].transition[symbol]
					)
					trans1 = max(
						dfa.state[key].transition[symbol],
						dfa.state[compareKey].transition[symbol]
					)
					print("transition on " + symbol + " to " + trans0 + trans1)
					if trans0 != trans1 and distinct[trans0][trans1]:
						print("is distinct")
						distinct[key][compareKey] = True
						modified = True
						print("modfied")
